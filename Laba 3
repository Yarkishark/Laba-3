"""С клавиатуры вводится два числа K и N. Квадратная матрица А(N,N), состоящая из 4-х равных по размерам подматриц, B,C,D,E 
заполняется случайным образом целыми числами в интервале [-10,10]. Для тестирования использовать не случайное заполнение, а целенаправленное. 
Для простоты все индексы в подматрицах относительные. Библиотечными методами пользоваться нельзя.
Формируется матрица F следующим образом: если в Е количество чисел, больших К в четных столбцах в области 1 больше, чем сумма 
чисел в нечетных строках в области 3, то поменять в Е симметрично области 1 и 3 местами, иначе В и С поменять местами несимметрично. 
При этом матрица А не меняется. После чего вычисляется выражение: A*F– K*AT . Выводятся по мере формирования А, F и 
все матричные операции последовательно."""

import random

def count_greater_than_k(val, k):
    count = 0
    if val > k:
        count += 1
    return count

def count_odd_row_sum(val):
    row_sum = 0
    row_sum += val
    return row_sum

def transpose_matrix(matrix):
    result = [[0 for _ in range(len(matrix))] for _ in range(len(matrix[0]))]
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result[j][i] = matrix[i][j]
    return result

K = int(input("Введите число K: "))
N = int(input("Введите число N: "))

A = [[random.randint(-10, 10) for _ in range(N)] for _ in range(N)]
print("Матрица A:")
for row in A:
    print(row)

E = [row[:N // 2] for row in A[:N // 2]]
B = [row[N // 2:] for row in A[:N // 2]]
D = [row[:N // 2] for row in A[N // 2:]]
C = [row[N // 2:] for row in A[N // 2:]]

count_col = 0
for i in range(len(E) // 2):
    for j in range(i, len(E)):
        if j % 2 == 0:
            count_col += count_greater_than_k(E[i][j], K)

sum_row = 0
for i in range(1, len(E) // 2):
    for j in range(len(E) - (i + 1)):
        if i % 2 == 1:
            sum_row += count_odd_row_sum(E[i][j])

F = A.copy()
e_copy = E.copy()
b_copy = B.copy()
c_copy = C.copy()

if count_col > sum_row:
    temp = e_copy
    e_copy = D
    D = temp
else:
    temp = b_copy
    b_copy = c_copy
    c_copy = temp

F = [e + b for e, b in zip(e_copy, b_copy)] + [d + c for d, c in zip(D, c_copy)]
print("Матрица F:")
for row in F:
    print(row)

A_transposed = transpose_matrix(A)
result_matrix = [[A[i][j]*F[i][j] - K*A_transposed[i][j] for j in range(N)] for i in range(N)]
print("Результат выражения A*F - K*A^T:")
for row in result_matrix:
    print(row)
