"""С клавиатуры вводится два числа K и N. Квадратная матрица А(N,N), состоящая из 4-х равных по размерам подматриц, B,C,D,E 
заполняется случайным образом целыми числами в интервале [-10,10]. Для тестирования использовать не случайное заполнение, а целенаправленное. 
Для простоты все индексы в подматрицах относительные. Библиотечными методами пользоваться нельзя.
Формируется матрица F следующим образом: если в Е количество чисел, больших К в четных столбцах в области 1 больше, чем сумма 
чисел в нечетных строках в области 3, то поменять в Е симметрично области 1 и 3 местами, иначе В и С поменять местами несимметрично. 
При этом матрица А не меняется. После чего вычисляется выражение: A*F– K*AT . Выводятся по мере формирования А, F и 
все матричные операции последовательно."""

import random

def transpose_matrix(matrix):
    result = [[0 for _ in range(len(matrix))] for _ in range(len(matrix[0]))]
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result[j][i] = matrix[i][j]
    return result

K = int(input("Введите значение K: "))
N = int(input("Введите значение N: "))

A = [[random.randint(-10, 10) for _ in range(N)] for _ in range(N)]

E = [row[:N // 2] for row in A[:N // 2]]
B = [row[N // 2:] for row in A[:N // 2]]
D = [row[:N // 2] for row in A[N // 2:]]
C = [row[N // 2:] for row in A[N // 2:]]

count = 0
'1 область в E'
for i in range((N // 2)):
    for j in range(N // 4):
        if i < len(E) and j < len(E[i]):
            if E[i][j] > K:
                count += 1
print("Количество чисел больше K в четных столбцах области 1:", count)

total_sum = 0
'3 область в E'
for i in range((N // 2) // 2, N // 2):
    for j in range((N // 2) - i - 1, i + 1):
        if i < len(E) and j < len(E[i]):
            if j % 2 != 0:
                total_sum += E[i][j]
print("Сумма элементов в нечетных строках области 3:", total_sum)

temp = B
matr_B = [row[:] for row in B]
matr_C = [row[:] for row in C]
matr_E = [row[:] for row in E]
if count > total_sum:
    temp_two = matr_E[:]
    for i in range(len(E)//2):
        matr_E[i], matr_E[len(E)//2 + (i-(len(E)//2+len(E)//2))] = (temp_two[len(E)//2 + (i-(len(E)//2+len(E)//2))], temp_two[i])
else:
    matr_B = matr_C
    matr_C = temp
F = [[matr_E[i % N//2][j % N//2] for j in range(N)] for i in range(N)]
for i in range(N):
    for j in range(N):
        if 0 <= i < N//2 and 0 <= j < N//2:
            F[i][j] = matr_E[i][j]
        elif 0 <= i < N//2 and N//2 <= j < N:
            F[i][j] = matr_B[i][j - N//2]
        elif N//2 <= i < N and 0 <= j < N//2:
            F[i][j] = D[i - N//2][j]
        else:
            F[i][j] = matr_C[i - N//2][j - N//2]
            
print("Матрица A:")
for row in A:
    print(row)

print("Матрица F:")
for row in F:
    print(row)

A_transposed = transpose_matrix(A)
result_matrix = [[A[i][j]*F[i][j] - K*A_transposed[i][j] for j in range(N)] for i in range(N)]
print("Результат выражения A*F - K*A^T:")
for row in result_matrix:
    print(row)

